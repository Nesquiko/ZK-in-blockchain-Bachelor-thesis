\chapter{Analysis}

The analysis section of the thesis starts with demonstration of interactive
proofs with goal to build up intuition behind interactive proofs \cite{Goldwasser1989,youtubeMOOCLecture1}.
This section explains how Alice attempts to prove to Bob that she knows an
algorithm, with which she computes some pair (N, y), such that this pair is
part of the quadratic residue language QR. Specifically, Alice needs to
convince Bob that there exists an x such that y equals x squared modulo N,
effectively placing the pair (N, y) within the QR language, which includes all
pairs where y is a quadratic residue of N.

The analysis section continues by highlighting a practical limitation of
interactive proofs in real world cryptography. It notes that for Alice to
prove something to multiple parties, she would need to engage in separate
interactions with each one. This approach is not scalable and becomes
impractical for widespread verification needs. However, the thesis introduces
the Fiat-Shamir transform \cite{Fiat}, a significant breakthrough that addresses this
issue. This transform allows for converting the interactive proof into a
non-interactive format by processing the interaction transcript, making the
proof more practical and scalable for real-world cryptographic applications.

While in theory any NP statement \cite{goldreich1991proofs} can be proven using
interactive proofs, practical implementation requires specific definition and
encoding of the statement. There are two main models of general computation,
those are circuits and turing machines. To trace the computation of a turing
machine, the representation needs to somehow handle memory and thus would accrue
more complexity than if a circuit is used. To represent a statement as a
circuit, an arithmetic circuit, a computation model composed of addition and
multiplication operations, is used. This circuit encodes the statement into a
form suitable for "zk-ifying", enabling the application of interactive proofs
to a broader range of practical scenarios.

The analysis section then explores various ZKP systems, each with unique
properties and proof constructions. The most renowned among these are SNARKs
(Succinct Non-interactive ARguments of Knowledge), Bulletproofs, and STARKs
(Scalable Transparent ARguments of Knowledge). These systems differ in aspects
such as computational efficiency, size of proofs, and the need (or lack
thereof) for a trusted setup. Each system offers advantages and challenges,
making them suitable for different applications.

The final part of the analysis examines how ZKP systems such as SNARKs enable
the creation of a stealth address scheme that upholds privacy and security.
This section assesses how these systems fulfill the necessary properties for a
stealth address scheme, focusing on their ability to ensure transaction
confidentiality while maintaining the anonymity of the recipient's identity.

\section{Proof of quadratic residuosity}

This first part focuses on demonstrating an interactive proof where Alice aims
to prove to Bob that she knows an algorithm, which computes some pair (N, y),
such that this pair is part of the quadratic residue language QR \cite{Goldwasser1989}.
QR is defined as:

\[QR = \lbrace(N, y): \exists x, y \equiv x^2 \pmod{N}\rbrace\]

\begin{figure}[h!]
    \centering
    \includegraphics[scale=0.6]{assets/images/qr_ip.png}
    \caption{Interactive proof of language QR}
    \label{fig:qr_ip}
    \vspace{0.5cm}
\end{figure}

\begin{enumerate}
    \item Alice generates pair (N, y)
    \item Alice picks a random $r$ such that $1 \leq r \leq N$ and $\gcd(r, N) = 1$
          and calculates $s \equiv r^2 \pmod{N}$
    \item Alice sends Bob $s$
    \item Alice asks Bob which value he wants. Either $\sqrt{s}$ or $\sqrt{sy}$, but he can not have both!
    \item Bob flips a coin and sends $b$ such that if coin landed on heads $b = 1$ else $b = 0$
    \item If $b = 1$ Alice sends to Bob $z \equiv \sqrt{sy} \equiv r \sqrt{y} \pmod{N}$ else she sends $z \equiv \sqrt{s} \equiv r \pmod{N}$
    \item Bob accepts if $z^2 = sy^b$
\end{enumerate}

If Alice was a cheating prover, and she didn't have the algorithm for
generating pairs from QR, then the probability that Bob's coin toss favors
Alice is one half. With one half probability Bob would ask cheating prover
Alice to give him the equation she can not solve, because if the prover is
cheating, she can not find the $\sqrt{s}$ and $\sqrt{sy}$. If she could,
that would mean that she is not cheating.

If the Alice's claim is true, Bob will accept. If Alice is not honest, and
cheats, all provers will not accept with probability $P(Accept) = 0.5$.
But this probability may not be satisfying enough. To make the probability
that Alice is cheating smaller, Bob and Alice can start the interaction once
again. This would lead to $P(Accept) = (0.5)^2$. They can redo the process
as many times as they wish, resulting in $P(Accept) = (0.5)^k$ where $k$
is how many different interactions they performed.

Thanks to the randomness of the coin toss, there are $2^k$ possibilities how
the interaction can go. Since Alice can't reliably predict what the random
coin toss will yield, she must be ready to provide both equations. Thus Bob is
convinced, that Alice isn't cheating, with probability $P(Accept) = (0.5)^k$,
and can accept the proof.

\section{Non-interactive proofs}

Interactive proofs require Alice to engage in a unique interaction with each
individual verifier, which is not scalable or feasible for widespread
application. Many ZKP protocols only require from the verifier a random input
(for instance, a coin toss). Protocols, in which the verifier's role is
generating some randomness and making it public are called public coin protocols \cite{Babai1988,Goldwasser1986}.
The paper "How To Prove Yourself: Practical Solutions to Identification and
Signature Problems"\cite{Fiat} by Fiat and Shamir demonstrates how these
interactive public coin protocols can be efficiently transformed into
non-interactive ones, offering a more scalable and practical solution for ZKPs.

To transform a interactive public coin protocol into a non-interactive,
Alice uses a random oracle which can provide a random coin toss based on some
input. In practice the source of randomness of the random oracle is a
cryptographic hash function, such as SHA256. Instead of sending messages back
and forth between Alice and Bob, Alice provides to Bob a transformed
transcript of the interaction. Since Bob's role in this interaction would only
be generating random coin toss, Alice can in advance query the random oracle
for this random value, and supply the message as an input to the query. The
transcript string would look like this $(msg1, query(msg1), msg2, ...)$, where $query$ is
the output from random oracle. This string and the public input of the proof
can then be published and anybody, not just Bob, can validate this proof
on their own.

In scenario when Alice sends only two messages and requires one random coin toss
from Bob,
\begin{figure}[h]
    \centering
    \includegraphics[scale=0.6]{assets/images/interactive_coin.png}
    \caption{Interactive public coin proof}
    \label{fig:interactive_coin}
    \vspace{0.5cm}
\end{figure}
Bob at the end can compute the validity of the proof from Alice with
$validate(public\:input\:x,\:msg1,\:coin\:toss,\:msg2) = accept/reject$

Then after applying Fiat-Shamir transform, Alice only sends one message with
the transcript string,
\begin{figure}[h]
    \centering
    \includegraphics[scale=0.6]{assets/images/non_interactive_coin.png}
    \caption{Non-interactive public coin proof}
    \label{fig:non_interactive_coin}
    \vspace{0.5cm}
\end{figure}
and Bob can compute the validity of the proof like this
$validate(public\:input\:x,\:msg1,\:query(msg1),\:msg2) = accept/reject$.

\section{Arithmetic circuit}

The computation model used to create ZKPs is an arithmetic circuit in a
finite field $\mathbb{F}_p$. The arithmetic circuit is a function which takes
$n$ elements from field $\mathbb{F}_p$ and returns one element from that field.

\[AC: \mathbb{F}^n \rightarrow F \]

The $AC$ can be represented as a directed acyclic graph, or a polynomial. For
example, polynomial $x_1x_2 + (x_2 + x_3)^2$ represents the same circuit as this
directed acyclic graph

\begin{figure}[h]
    \centering
    \includegraphics[scale=0.25]{assets/images/dag_example.png}
    \caption{Graph representation of arithmetic circuit}
    \label{fig:dag_example}
    \vspace{0.5cm}
\end{figure}

Another representation of a arithmetic circuits is called a Rank 1 Constraint
System (R1CS). R1CS is a system of equations of a form $\alpha \times \beta = \gamma$,
where $\alpha, \beta, \gamma$ are affine combinations of variables $w$ and $x$,
where $w$ is a witness (private inputs) and $x$ is a public inputs.

These are some examples of R1CS equations:
\begin{displaymath}
	\begin{array}{l}
		(w_1 + x_3) \times (w_2 - x_1 + 1) = w_3 	\\
		w_1 \times w_1 = x_1						\\
		w_1 \times x_2 = w_3
	\end{array}
\end{displaymath}

And here is an example of a invalid R1CS equations, because they are not linear
combinations of variables $w$ and $x$:

\begin{displaymath}
	\begin{array}{l}
		w_1 \times x_3 \times w_2 = w_3	\\
		w_1 \times w_1 \times w_1 = x_1	\\
		w_1 \times x_2 + w_3 = w_4 \times w_5
	\end{array}
\end{displaymath}

To constrain the operation $w_1^3 = x_1$ in R1CS, there must be two equations, with
a new intermediary variable $w_2$:

\begin{displaymath}
	\begin{array}{l}
		w_1 \times w_1 = w_2	\\
		w_1 \times w_2 = x_1
	\end{array}
\end{displaymath}




% While in theory any NP statement \cite{goldreich1991proofs} can be proven using
% interactive proofs, practical implementation requires specific definition and
% encoding of the statement. There are two main models of general computation,
% those are circuits and turing machines. To trace the computation of a turing
% machine, the representation needs to somehow handle memory and thus would accrue
% more complexity than if a circuit is used. To represent a statement as a
% circuit, an arithmetic circuit, a computation model composed of addition and
% multiplication operations, is used. This circuit encodes the statement into a
% form suitable for "zk-ifying", enabling the application of interactive proofs
% to a broader range of practical scenarios.

% the interaction part is non-practical => Fiat Shamir

% R1Cs

% SNARKs - from Dan Boneh MOOC
% commitments
% SZDL lemma = a polynomial is zero-polynomial with d\/p probability = zero - test
